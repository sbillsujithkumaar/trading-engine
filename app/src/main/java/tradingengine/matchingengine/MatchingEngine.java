package tradingengine.matchingengine;

import tradingengine.book.OrderBook;
import tradingengine.book.OrderBookSide;
import tradingengine.book.OrderLocator;
import tradingengine.domain.Order;
import tradingengine.domain.OrderSide;
import tradingengine.domain.Trade;
import tradingengine.events.EventDispatcher;
import tradingengine.events.OrderBookEvent;
import tradingengine.events.OrderBookEventType;
import tradingengine.events.TradeExecutedEvent;
import tradingengine.persistence.FileTradeStore;

import java.time.Clock;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * Deterministic matching engine implementing price–time priority.
 *
 * <p>
 * The MatchingEngine is responsible for:
 * <ul>
 *   <li>Accepting incoming orders</li>
 *   <li>Matching them against resting liquidity</li>
 *   <li>Producing {@link Trade} records for each execution</li>
 *   <li>Maintaining consistent order book state</li>
 * </ul>
 *
 * <p>
 * This class orchestrates matching but delegates:
 * <ul>
 *   <li>Order storage to {@link OrderBook}</li>
 *   <li>Order state transitions to {@link Order}</li>
 *   <li>Event emission to {@link tradingengine.events.EventDispatcher}</li>
 * </ul>
 *
 * <p>
 * Matching rules:
 * <ul>
 *   <li>BUY matches SELL when buyPrice ≥ sellPrice</li>
 *   <li>Execution occurs at the resting order's price</li>
 *   <li>FIFO ordering is enforced at each price level</li>
 *   <li>Cancelled orders are removed immediately from the book</li>
 * </ul>
 */
public class MatchingEngine {

    private final OrderBook book;
    private final Clock clock;
    private final EventDispatcher dispatcher;
    private final FileTradeStore tradeStore;

    /**
     * Creates a matching engine with an existing order book, clock, dispatcher, and trade store.
     *
     * @param book the order book instance
     * @param clock the time source for trade timestamps
     * @param dispatcher the event dispatcher
     * @param tradeStore the trade persistence store
     */
    public MatchingEngine(OrderBook book, Clock clock, EventDispatcher dispatcher, FileTradeStore tradeStore) {
        this.book = Objects.requireNonNull(book, "order book must not be null");
        this.clock = Objects.requireNonNull(clock, "clock must not be null");
        this.dispatcher = Objects.requireNonNull(dispatcher, "dispatcher must not be null");
        this.tradeStore = Objects.requireNonNull(tradeStore, "tradeStore must not be null");
    }

    /**
     * Submits an incoming order to the matching engine.
     *
     * <p>
     * Processing flow:
     * <ol>
     *   <li>Attempt to match the order against resting liquidity</li>
     *   <li>Generate one or more trades if matching occurs</li>
     *   <li>Add remaining quantity to the order book if unfilled</li>
     * </ol>
     *
     * @param incoming the incoming order
     * @return list of trades generated by this submission (possibly empty)
     */
    public List<Trade> submit(Order incoming) {
        // Validate input - incoming Order must not be null
        Objects.requireNonNull(incoming, "incoming order must not be null");

        // List to accumulate resulting trades
        List<Trade> trades = new ArrayList<>();

        // Before storing incoming order, match that order with opposing resting orders 
        // and come up with list of possible trades
        matchIncoming(incoming, trades);

        // If incoming order is still active (not fully filled), add to order book
        if (incoming.isActive()) {
            book.addOrder(incoming);
            dispatcher.publish(new OrderBookEvent(
                    incoming.getSide(),
                    incoming.getPrice(),
                    OrderBookEventType.ADD,
                    Instant.now(clock)
            ));
        }

        return trades;
    }

    /**
     * Cancel an order by id.
     *
     * @param orderId the order id to cancel
     * @return {@code true} if the order was found and cancelled
     */
    public boolean cancel(String orderId) {
        Objects.requireNonNull(orderId, "orderId must not be null");
        Optional<OrderLocator> locator = book.cancelOrderAndGetLocator(orderId);
        if (locator.isEmpty()) {
            return false;
        }
        OrderLocator cancelled = locator.get();
        dispatcher.publish(new OrderBookEvent(
                cancelled.side(),
                cancelled.price(),
                OrderBookEventType.CANCEL,
                Instant.now(clock)
        ));
        return true;
    }


    /**
     * Attempts to match an incoming order against the opposite side of the book
     * until it is fully filled or no further execution is possible.
     */
    private void matchIncoming(Order incoming, List<Trade> trades) {
        // Loop terminates when no match is possible (no resting order or prices do not cross).
        while (incoming.isActive()) {
            OrderBookSide oppositeSide = (incoming.getSide() == OrderSide.BUY)
                    ? book.sellSide()
                    : book.buySide();

            Order resting = oppositeSide.peekBestOrderOrNull();
            if (resting == null) {
                break;
            }
            if (!incoming.canMatch(resting.getPrice())) {
                break;
            }

            Trade trade = executeTrade(incoming, resting);
            trades.add(trade);
            dispatcher.publish(new TradeExecutedEvent(trade, trade.timestamp()));

            OrderSide restingSide = (incoming.getSide() == OrderSide.BUY) ? OrderSide.SELL : OrderSide.BUY;
            Order removed = book.removeBestOrderIfInactive(restingSide);
            if (removed != null) {
                dispatcher.publish(new OrderBookEvent(
                        removed.getSide(),
                        removed.getPrice(),
                        OrderBookEventType.REMOVE,
                        Instant.now(clock)
                ));
            }
        }
    }

    /**
     * Executes a single trade between an incoming order and a resting order.
     *
     * <p>
     * Execution rules:
     * <ul>
     *   <li>Fill quantity = min(remaining quantities)</li>
     *   <li>Trade price = resting order's price</li>
     * </ul>
     *
     * <p>
     * This method updates both orders' remaining quantities and derives their statuses.
     *
     * @param incoming the incoming order
     * @param resting the resting order
     * @return the resulting trade
     */
    private Trade executeTrade(Order incoming, Order resting) {
        // Validity Check: orders must be on opposite sides
        if (incoming.getSide() == resting.getSide()) {
            throw new IllegalArgumentException("Orders must be on opposite sides to execute trade");
        }

        // Determine which is BUY and which is SELL
        Order buy = (incoming.getSide() == OrderSide.BUY) ? incoming : resting;
        Order sell = (incoming.getSide() == OrderSide.SELL) ? incoming : resting;

        // Calculate fill quantity
        long fillQty = Math.min(buy.getRemainingQty(), sell.getRemainingQty());
        if (fillQty <= 0) {
            throw new IllegalStateException("Cannot execute trade with zero quantity");
        }

        // Execute the fills on both orders
        buy.execute(fillQty);
        sell.execute(fillQty);

        // Create and persist the Trade record
        Trade trade = new Trade(
                buy.getId(),
                sell.getId(),
                resting.getPrice(),
                fillQty,
                Instant.now(clock)
        );
        tradeStore.save(trade);
        return trade;
    }

    /**
     * @return a read-only view of all trades in execution order.
     */
    public List<Trade> tradeHistory() {
        return tradeStore.findAll();
    }
}
