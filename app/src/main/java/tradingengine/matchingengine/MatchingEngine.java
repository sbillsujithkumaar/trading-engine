package tradingengine.matchingengine;

import tradingengine.book.OrderBook;
import tradingengine.domain.Order;
import tradingengine.domain.OrderSide;
import tradingengine.domain.Trade;

import java.time.Clock;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Deterministic matching engine implementing price–time priority.
 *
 * <p>
 * The MatchingEngine is responsible for:
 * <ul>
 *   <li>Accepting incoming orders</li>
 *   <li>Matching them against resting liquidity</li>
 *   <li>Producing {@link Trade} records for each execution</li>
 *   <li>Maintaining consistent order book state</li>
 * </ul>
 *
 * <p>
 * This class orchestrates matching but delegates:
 * <ul>
 *   <li>Order storage to {@link OrderBook}</li>
 *   <li>Order state transitions to {@link Order}</li>
 * </ul>
 *
 * <p>
 * Matching rules:
 * <ul>
 *   <li>BUY matches SELL when buyPrice ≥ sellPrice</li>
 *   <li>Execution occurs at the resting order's price</li>
 *   <li>FIFO ordering is enforced at each price level</li>
 * </ul>
 */
public class MatchingEngine {

    private final OrderBook book;
    private final Clock clock;

    /**
     * Creates a matching engine with a fresh, empty order book
     */
    public MatchingEngine() {
        this(new OrderBook(), Clock.systemUTC());
    }

    /**
     * Creates a matching engine with an existing order book
     *
     * @param book the order book instance
     */
    public MatchingEngine(OrderBook book) {
        this(book, Clock.systemUTC());
    }

    /**
     * Creates a matching engine with an existing order book and clock
     *
     * @param book the order book instance
     * @param clock the time source for trade timestamps
     */
    public MatchingEngine(OrderBook book, Clock clock) {
        this.book = Objects.requireNonNull(book, "order book must not be null");
        this.clock = Objects.requireNonNull(clock, "clock must not be null");
    }

    /**
     * Submits an incoming order to the matching engine.
     *
     * <p>
     * Processing flow:
     * <ol>
     *   <li>Attempt to match the order against resting liquidity</li>
     *   <li>Generate one or more trades if matching occurs</li>
     *   <li>Add remaining quantity to the order book if unfilled</li>
     * </ol>
     *
     * @param incoming the incoming order
     * @return list of trades generated by this submission (possibly empty)
     */
    public List<Trade> submit(Order incoming) {
        // Validate input - incoming Order must not be null
        Objects.requireNonNull(incoming, "incoming order must not be null");

        // List to accumulate resulting trades
        List<Trade> trades = new ArrayList<>();

        // Before storing incoming order, match that order with opposing resting orders 
        // and come up with list of possible trades
        matchIncoming(incoming, trades);

        // If incoming order is still active (not fully filled), add to order book
        if (incoming.isActive()) {
            book.addOrder(incoming);
        }

        return trades;
    }
    

    /**
     * Attempts to match an incoming order against the opposite side of the book
     * until it is fully filled or no further execution is possible.
     */
    private void matchIncoming(Order incoming, List<Trade> trades) {
        while (incoming.isActive() && book.canExecuteIncoming(incoming)) {

            Trade trade = (incoming.getSide() == OrderSide.BUY)
                    ? matchIncomingBuy(incoming)
                    : matchIncomingSell(incoming);

            trades.add(trade);
        }
    }

    /**
     * Matches an incoming BUY order against the best resting SELL order.
     *
     * @param incomingBuy the incoming BUY order
     * @return the executed trade, or {@code null} if no match is possible
     */
    private Trade matchIncomingBuy(Order incomingBuy) {
        Order restingSell = book.sellSide().peekBestOrder();

        Trade trade = executeTrade(incomingBuy, restingSell);

        // Remove completed resting order if necessary
        book.sellSide().removeHeadOrderIfInactive();

        return trade;
    }

    /**
     * Matches an incoming SELL order against the best resting BUY order.
     *
     * @param incomingSell the incoming SELL order
     * @return the executed trade, or {@code null} if no match is possible
     */
    private Trade matchIncomingSell(Order incomingSell) {
        Order restingBuy = book.buySide().peekBestOrder();

        Trade trade = executeTrade(incomingSell, restingBuy);

        // Remove completed resting order if necessary
        book.buySide().removeHeadOrderIfInactive();

        return trade;
    }

    /**
     * Executes a single trade between an incoming order and a resting order.
     *
     * <p>
     * Execution rules:
     * <ul>
     *   <li>Fill quantity = min(remaining quantities)</li>
     *   <li>Trade price = resting order's price</li>
     * </ul>
     *
     * <p>
     * This method updates both orders' remaining quantities and derives their statuses.
     *
     * @param incoming the incoming order
     * @param resting the resting order
     * @return the resulting trade
     */
    private Trade executeTrade(Order incoming, Order resting) {
        // Validity Check: orders must be on opposite sides
        if (incoming.getSide() == resting.getSide()) {
            throw new IllegalArgumentException("Orders must be on opposite sides to execute trade");
        }

        // Determine which is BUY and which is SELL
        Order buy = (incoming.getSide() == OrderSide.BUY) ? incoming : resting;
        Order sell = (incoming.getSide() == OrderSide.SELL) ? incoming : resting;

        // Calculate fill quantity
        long fillQty = Math.min(buy.getRemainingQty(), sell.getRemainingQty());
        if (fillQty <= 0) {
            throw new IllegalStateException("Cannot execute trade with zero quantity");
        }

        // Execute the fills on both orders
        buy.execute(fillQty);
        sell.execute(fillQty);

        // Create and return the Trade record
        return new Trade(
                buy.getId(),
                sell.getId(),
                resting.getPrice(),
                fillQty,
                Instant.now(clock)
        );
    }
}
